import * as pg from 'pg';
import { Command, Connection as BaseConnection, ConnectionOptions } from 'sqlcmd';
import QueryStream from './stream';
export interface PGConnectionOptions extends ConnectionOptions {
    /** Database name */
    database?: string;
    /** Username */
    user?: string;
    /** Password */
    password?: string;
    /** Hostname (for TCP connections) */
    host?: string;
    /** Port (for TCP connections) */
    port?: number;
    /** Use SSL? */
    ssl?: boolean;
}
export declare class Connection extends BaseConnection {
    options: PGConnectionOptions;
    constructor(options: PGConnectionOptions);
    /**
    Run sql query or pg.Query instance on configured SQL connection with given
    parameters.
  
    sql
      SQL query (any PostgreSQL command) or pg.Query object (determined by whether
      sql.submit is a function)
    args
      parameters to accompany the SQL command
    callback
      function to call when the query has completed, or if it encountered an error
  
    */
    query(sql: string | pg.Query, args: any[], callback: (error: Error, rows?: any[]) => void): void;
    /**
    Returns a readable Stream instance (a QueryStream from sqlcmd-pg/stream, to be
    precise).
    */
    queryStream(sql: string, args: any[]): QueryStream;
    /**
    Proxies directly to Connection#query (implemented in sqlcmd-pg)
    */
    executeSQL(sql: string, args: any[], callback: (error: Error, rows?: any[]) => void): void;
    /**
    Process a sqlcmd.Command, which boils down to a single SQL string and its
    parameters directly to Connection#query (implemented in sqlcmd-pg)
  
    pg handles the overloading of optional args.
    */
    executeCommand<R>(command: Command<R>, callback: (error: Error, result?: R) => void): void;
    /**
    Call pg.connect() with this connection's options, and callback with a Client
    from the pool. When you call doneCallback, the Client will be returned to the
    pool, and the given outerCallback will be called with the same arguments.
    */
    getClient(outerCallback: (error: Error, ...args: any[]) => void, callback: (error: Error, client: pg.Client, doneCallback: (error: Error, ...args: any[]) => void) => void): void;
    /**
    Calls pg.end(), to disconnect all idle clients and dispose of all pools.
    Does not stop or close in-progress clients.
    */
    close(): void;
    postgresConnection(): Connection;
    /**
    Check if the database used by this connection exists. This method creates a new
    connection to the special 'postgres' database using the same connection options,
    but with a different database name.
    */
    databaseExists(callback: (error: Error, exists?: boolean) => void): void;
    /** Create the database used by this connection.
  
    We can't specify the database name as an argument, so we just put it into the string raw.
    This is unsafe, of course, but if you want to break your own computer, go for it.
    */
    createDatabase(callback: (error?: Error) => void): void;
    /** Check if the database exists.
    1. If it does not exist, create it.
    2. If it already exists, do nothing.
    */
    createDatabaseIfNotExists(callback: (error: Error, created?: boolean) => void): void;
    /** Drop the database used by this connection.
  
    Vulnerable to injection via the database name!
    */
    dropDatabase(callback: (error?: Error) => void): void;
    /** Check if the database exists.
    1. If it does not exist, do nothing.
    2. If it does exist, drop it.
    */
    dropDatabaseIfExists(callback: (error: Error, dropped?: boolean) => void): void;
}
