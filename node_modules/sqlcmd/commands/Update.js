"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Command_1 = require('../Command');
var UpdateBase = (function (_super) {
    __extends(UpdateBase, _super);
    function UpdateBase(table) {
        _super.call(this);
        this.statement.table = table;
        this.statement.sets = []; // equations / equalities (column-expression pairs)
        this.statement.wheres = [];
        this.statement.returning = [];
    }
    /** Update#toSQL()
  
    Generates a string like:
      UPDATE users SET ip = $1, user_agent = $2 WHERE id = $3
    */
    UpdateBase.prototype.toSQL = function () {
        var parts = ['UPDATE', this.statement.table];
        if (this.statement.sets.length > 0) {
            parts.push('SET', this.statement.sets.join(', '));
        }
        if (this.statement.wheres.length > 0) {
            parts.push('WHERE', this.statement.wheres.join(' AND '));
        }
        if (this.statement.returning.length > 0) {
            parts.push('RETURNING', this.statement.returning.join(', '));
        }
        return parts.join(' ');
    };
    UpdateBase.prototype._where = function (sql) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var interpolatedSql = this.interpolateQuestionMarks(sql, args);
        this.statement.wheres.push(interpolatedSql);
        return this;
    };
    UpdateBase.prototype.where = function (sql) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return (_a = this.clone())._where.apply(_a, [sql].concat(args));
        var _a;
    };
    UpdateBase.prototype._whereEqual = function (hash) {
        for (var column in hash) {
            var value = hash[column];
            if (value !== undefined) {
                this.statement.wheres.push(column + ' = $' + column);
                this.parameters[column] = value;
            }
        }
        return this;
    };
    /**
    Just like Select#whereEqual
    */
    UpdateBase.prototype.whereEqual = function (hash) {
        return this.clone()._whereEqual(hash);
    };
    UpdateBase.prototype._set = function (sql) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        sql = this.interpolateQuestionMarks(sql, args);
        this.statement.sets.push(sql);
        return this;
    };
    /**
    SQL can do more than just stuff like "... SET name = 'Chris' ...", it can also
    increment, e.g., "... SET counter = counter + 1 ...", so we call this _set,
    and have a separate _setEqual
    */
    UpdateBase.prototype.set = function (sql) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return (_a = this.clone())._set.apply(_a, [sql].concat(args));
        var _a;
    };
    UpdateBase.prototype._setEqual = function (hash) {
        for (var column in hash) {
            var value = hash[column];
            if (value !== undefined) {
                this.statement.sets.push(column + ' = $' + column);
                this.parameters[column] = value;
            }
        }
        return this;
    };
    /**
    Given a hash like
        {
          artist: 'Nathaniel Merriweather',
          title: 'Strangers On A Train'
        }
  
    Add this.statement.sets like:
        [
          'artist = $artist',
          'title = $title',
        ]
  
    While extending the parameters with:
        {
          artist: 'Nathaniel Merriweather',
          title: 'Strangers On A Train',
        }
  
    This function presumes that all object keys are safe, and all object values are unsafe.
    In this way, it's a lot like the Select#_whereEqual() method
  
    If that's not true, you should add values to `this.eqs` directly.
    */
    UpdateBase.prototype.setEqual = function (hash) {
        return this.clone()._setEqual(hash);
    };
    /** Update#_returning(...columns: string[])
  
    Call like:
  
        db.Update('users').set({active: false}).returning('*')
  
    to get back all updated rows.
    */
    UpdateBase.prototype._returning = function () {
        var columns = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            columns[_i - 0] = arguments[_i];
        }
        (_a = this.statement.returning).push.apply(_a, columns);
        return this;
        var _a;
    };
    UpdateBase.prototype.returning = function () {
        var columns = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            columns[_i - 0] = arguments[_i];
        }
        return (_a = this.clone())._returning.apply(_a, columns);
        var _a;
    };
    return UpdateBase;
}(Command_1.default));
exports.UpdateBase = UpdateBase;
var Update = (function (_super) {
    __extends(Update, _super);
    function Update() {
        _super.apply(this, arguments);
    }
    return Update;
}(UpdateBase));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Update;
var UpdateOne = (function (_super) {
    __extends(UpdateOne, _super);
    function UpdateOne(table) {
        _super.call(this, table);
        this._oneResult = true;
    }
    return UpdateOne;
}(UpdateBase));
exports.UpdateOne = UpdateOne;
