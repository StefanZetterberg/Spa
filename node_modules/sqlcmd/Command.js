"use strict";
/**
Deep-copy a plain object or array. There is no special handling for other
types of objects; it simply copies everything else by reference.
*/
function clone(obj) {
    // typeof null == 'object' (wat), so we check for that case early.
    if (obj === null) {
        return obj;
    }
    else if (Array.isArray(obj)) {
        return obj.map(clone);
    }
    else if (obj instanceof Date) {
        return new Date(obj);
    }
    else if (typeof obj === 'object') {
        var copy = {};
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                copy[key] = clone(obj[key]);
            }
        }
        return copy;
    }
    else {
        // typeof undefined == 'undefined', so that will pass through here,
        // along with strings, numbers, true, and false.
        return obj;
    }
}
/**
Command represents an abstract SQL command.

@param {statement} Contains the fields that, together with the class, determine
       how to generate this command's actual SQL, e.g., when calling Command#toSQL().
@param {parameters} The parameters used in a parameterized query, matching the
       $name sequences in the generated SQL.
@param {parameters_i} Used to keep track of positional parameters.
*/
var Command = (function () {
    function Command() {
        this.connection = undefined;
        this.statement = {};
        this.parameters = {};
        this.parameters_i = 1;
        this._oneResult = false;
    }
    /**
    When a command is created via a connection's instance methods, e.g.,
    conn.Select(...), the connection will be attached to the command. This method
    calls #executeCommand(...) on the originating connection, and will throw an Error if
    there is no available connection. This may be the case if the command was
    imported and instantiated directly, i.e., by calling
    Select = require('sqlcmd/commands/select').
  
    callback
      sent directly to this.connection.execute(command, callback)
    */
    Command.prototype.execute = function (callback) {
        var _this = this;
        return this.connection.executeCommand(this, function (error, results) {
            if (error)
                return callback(error);
            callback(null, _this._oneResult ? results[0] : results);
        });
    };
    /**
    If there is a global type 'Promise' available, use it; otherwise, throw an exception.
    */
    Command.prototype.executePromise = function () {
        var _this = this;
        if (typeof Promise !== 'undefined') {
            return new Promise(function (resolve, reject) {
                _this.execute(function (error, result) { return error ? reject(error) : resolve(result); });
            });
        }
        throw new TypeError('"Promise" is not an available type');
    };
    Command.prototype.clone = function () {
        var copy = Object.create(this.constructor.prototype);
        copy.connection = this.connection;
        copy.statement = clone(this.statement);
        copy.parameters = clone(this.parameters);
        copy.parameters_i = this.parameters_i;
        copy._oneResult = this._oneResult;
        return copy;
    };
    /**
    Replace a SQL string like 'name = ?' and args like ['chris']
    with a SQL string like 'name = $1' while updating Params#store
    so that Params#store['1'] = 'chris'
  
    Returns a string with all ?'s replaced with $1, $2, $3, etc., using the next
    available $N in Params, based on the current value of Params#index.
  
    If there are more ?'s than items in args, it will use the parameterized value,
    `undefined`, for the later ?'s. If there are more items in args than there are
    ?'s, those later items will be ignored.
    */
    Command.prototype.interpolateQuestionMarks = function (sql, args) {
        var _this = this;
        if (typeof (sql) !== 'string') {
            var message = "Cannot interpolate question marks in object of type \"" + typeof (sql) + "\"; only strings are allowed.";
            // error.object = sql;
            throw new Error(message);
        }
        return sql.replace(/\?/g, function (match) {
            var name = (_this.parameters_i++).toString();
            _this.parameters[name] = args.shift();
            return '$' + name;
        });
    };
    Command.prototype.nextParameterName = function () {
        return (this.parameters_i++).toString();
    };
    return Command;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Command;
