"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Command_1 = require('../Command');
var InsertBase = (function (_super) {
    __extends(InsertBase, _super);
    function InsertBase(table) {
        _super.call(this);
        this.statement.table = table;
        this.statement.columns = [];
        // values should be as long as columns; it'll often be $variables, but not necessarily
        this.statement.values = [];
        this.statement.returning = [];
    }
    /**
    Generates a string like:
      INSERT INTO responses (user_id, experiment_id, stimulus_id, value)
        VALUES ($1, $2, $3, $4)
    */
    InsertBase.prototype.toSQL = function () {
        var parts = ['INSERT INTO', this.statement.table];
        // no columns means ALL columns, in default order
        if (this.statement.columns.length > 0) {
            parts.push('(' + this.statement.columns.join(', ') + ')');
        }
        // no values means defaults only
        if (this.statement.values.length === 0) {
            parts.push('DEFAULT VALUES');
        }
        else {
            parts.push('VALUES (' + this.statement.values.join(', ') + ')');
        }
        if (this.statement.returning.length > 0) {
            // not default since sqlite can't handle it
            parts.push('RETURNING', this.statement.returning.join(', '));
        }
        return parts.join(' ');
    };
    InsertBase.prototype._add = function (column, value) {
        this.statement.columns.push(column);
        this.parameters[column] = value;
        this.statement.values.push('$' + column);
        return this;
    };
    InsertBase.prototype.add = function (column, value) {
        return this.clone()._add(column, value);
    };
    InsertBase.prototype._set = function (hash) {
        for (var column in hash) {
            var value = hash[column];
            if (value !== undefined) {
                this._add(column, value);
            }
        }
        return this;
    };
    /**
    This function presumes that all hash keys are safe, and all object values are unsafe.
  
    Ignores undefined values.
    */
    InsertBase.prototype.set = function (hash) {
        return this.clone()._set(hash);
    };
    InsertBase.prototype._returning = function () {
        var columns = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            columns[_i - 0] = arguments[_i];
        }
        (_a = this.statement.returning).push.apply(_a, columns);
        return this;
        var _a;
    };
    /**
    Call like:
  
        db.Insert('users').set({name: 'Chris'}).returning('*')
  
    to get back the full inserted row. Useful if you want the primary key or
    other generated / default values.
    */
    InsertBase.prototype.returning = function () {
        var columns = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            columns[_i - 0] = arguments[_i];
        }
        return (_a = this.clone())._returning.apply(_a, columns);
        var _a;
    };
    return InsertBase;
}(Command_1.default));
exports.InsertBase = InsertBase;
var Insert = (function (_super) {
    __extends(Insert, _super);
    function Insert() {
        _super.apply(this, arguments);
    }
    return Insert;
}(InsertBase));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Insert;
/**
The user is still responsible for adding the .returning('*') clause.
*/
var InsertOne = (function (_super) {
    __extends(InsertOne, _super);
    function InsertOne(table) {
        _super.call(this, table);
        this._oneResult = true;
    }
    return InsertOne;
}(InsertBase));
exports.InsertOne = InsertOne;
