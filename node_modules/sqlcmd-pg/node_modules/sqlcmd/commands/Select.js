var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Command_1 = require('../Command');
var SelectBase = (function (_super) {
    __extends(SelectBase, _super);
    function SelectBase(table) {
        _super.call(this);
        this.statement.table = table;
        this.statement.columns = [];
        this.statement.wheres = [];
        this.statement.group_bys = [];
        this.statement.order_bys = [];
    }
    SelectBase.prototype.toSQL = function () {
        var parts = ['SELECT'];
        // add columns
        if (this.statement.columns.length === 0) {
            parts.push('*');
        }
        else {
            parts.push(this.statement.columns.join(', '));
        }
        // from table
        parts.push('FROM', this.statement.table);
        // where ...
        if (this.statement.wheres.length > 0) {
            parts.push('WHERE', this.statement.wheres.join(' AND '));
        }
        // group by ...
        if (this.statement.group_bys.length > 0) {
            parts.push('GROUP BY', this.statement.group_bys.join(', '));
        }
        // order by ...
        if (this.statement.order_bys.length > 0) {
            parts.push('ORDER BY', this.statement.order_bys.join(', '));
        }
        // limit
        if (this.statement.limit) {
            parts.push('LIMIT', this.statement.limit);
        }
        // offset
        if (this.statement.offset) {
            parts.push('OFFSET', this.statement.offset);
        }
        return parts.join(' ');
    };
    SelectBase.prototype._add = function () {
        var columns = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            columns[_i - 0] = arguments[_i];
        }
        (_a = this.statement.columns).push.apply(_a, columns);
        return this;
        var _a;
    };
    SelectBase.prototype.add = function () {
        var columns = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            columns[_i - 0] = arguments[_i];
        }
        return (_a = this.clone())._add.apply(_a, columns);
        var _a;
    };
    SelectBase.prototype._where = function (sql) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var interpolatedSql = this.interpolateQuestionMarks(sql, args);
        this.statement.wheres.push(interpolatedSql);
        return this;
    };
    /** Select#_where(sql: string, ...args: any[])
  
    Add a WHERE statement to be AND-merged with any other WHERE statements.
  
    sql
      Any SQL expression that evaluates to a truth value. It may contain multiple
      "?" placeholders -- as many ?'s as there are items in the args array.
    args
      SQL parameters to accompany the given SQL expression [optional]
  
    See also: Select#_whereEqual(...)
    */
    SelectBase.prototype.where = function (sql) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return (_a = this.clone())._where.apply(_a, [sql].concat(args));
        var _a;
    };
    SelectBase.prototype._whereEqual = function (hash) {
        for (var column in hash) {
            var value = hash[column];
            if (value !== undefined) {
                this.statement.wheres.push(column + ' = $' + column);
                this.parameters[column] = value;
            }
        }
        return this;
    };
    /**
    This functions just like calling where() several times with simple
    ('column = ?', value) pairs. Be careful with this one! only the hash's
    values will be escaped, so SQL injection is totally possible with the keys.
    */
    SelectBase.prototype.whereEqual = function (hash) {
        return this.clone()._whereEqual(hash);
    };
    SelectBase.prototype._whereIn = function (column, list) {
        var _this = this;
        if (list.length > 0) {
            var inlist = list.map(function (item) {
                var name = _this.nextParameterName();
                _this.parameters[name] = item;
                return '$' + name;
            }).join(', ');
            this.statement.wheres.push(column + ' IN (' + inlist + ')');
        }
        else {
            // 0-length lists get special treatment.
            // something is never an element of the empty list, but 'WHERE x IN ()'
            // is a syntax error, not FALSE, in PostgreSQL
            this.statement.wheres.push('FALSE');
        }
        return this;
    };
    /** Though ugly, apparently this is just how it works:
  
    https://github.com/brianc/node-postgres/issues/431
  
    Ends up with something like 'x IN($arg1, $arg2, $arg3)' and then
      {arg1: 'a', arg2: 'b', arg3: 'c'} in the properties
    Thus, each item in list is escaped (but column is not)
  
    An easier way is to use something like x = ANY($someArray)
    */
    SelectBase.prototype.whereIn = function (column, list) {
        return this.clone()._whereIn(column, list);
    };
    SelectBase.prototype._groupBy = function () {
        var columns = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            columns[_i - 0] = arguments[_i];
        }
        (_a = this.statement.group_bys).push.apply(_a, columns);
        return this;
        var _a;
    };
    /** Vulnerable to SQL injection! */
    SelectBase.prototype.groupBy = function () {
        var columns = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            columns[_i - 0] = arguments[_i];
        }
        return (_a = this.clone())._groupBy.apply(_a, columns);
        var _a;
    };
    SelectBase.prototype._orderBy = function () {
        var columns = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            columns[_i - 0] = arguments[_i];
        }
        (_a = this.statement.order_bys).push.apply(_a, columns);
        return this;
        var _a;
    };
    /** Vulnerable to SQL injection! */
    SelectBase.prototype.orderBy = function () {
        var columns = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            columns[_i - 0] = arguments[_i];
        }
        return (_a = this.clone())._orderBy.apply(_a, columns);
        var _a;
    };
    SelectBase.prototype._offset = function (offset) {
        this.statement.offset = '$offset';
        this.parameters.offset = offset;
        return this;
    };
    SelectBase.prototype.offset = function (offset) {
        return this.clone()._offset(offset);
    };
    SelectBase.prototype._limit = function (limit) {
        this.statement.limit = '$limit';
        this.parameters.limit = limit;
        return this;
    };
    SelectBase.prototype.limit = function (limit) {
        return this.clone()._limit(limit);
    };
    return SelectBase;
})(Command_1.default);
exports.SelectBase = SelectBase;
var Select = (function (_super) {
    __extends(Select, _super);
    function Select() {
        _super.apply(this, arguments);
    }
    return Select;
})(SelectBase);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Select;
var SelectOne = (function (_super) {
    __extends(SelectOne, _super);
    function SelectOne(table) {
        _super.call(this, table);
        this.statement.limit = '1';
        this._oneResult = true;
    }
    return SelectOne;
})(SelectBase);
exports.SelectOne = SelectOne;
